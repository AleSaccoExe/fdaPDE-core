#ifndef __VECTOR_SPACE_H__
#define __VECTOR_SPACE_H__

#include "../utils/Symbols.h"
#include <vector>

template <unsigned int N> using VectorSpace = std::vector<SVector<N>>;

// a template class to perform geometric operations in general vector and affine spaces
template <unsigned int N>
class Geometry {
public:
  // produce an orthonormal basis from the input set of vectors given in input (implementation of the modified gram schmidt method)
  static VectorSpace<N> orthonormalize(const VectorSpace<N>& basis);

  // project point x onto the space generated by the given orthonormal basis
  static DVector projectOnto(const VectorSpace<N>& basis, const SVector<N>& x);

  // project point x into the space generated by the given orthonormal basis
  static SVector<N> projectInto(const VectorSpace<N>& basis, const SVector<N>& x);

  // returns the euclidean distance between the point x and the space spanned by basis
  static double getL2Distance(const VectorSpace<N>& basis, const SVector<N>& offset, const SVector<N>& x);
};

// orthonormalize a given set of vectors, producing an orthonormal basis for the vector space spanned by
// the set of vectors passed as input (implementation of the modified gram-schmidt method)
template <unsigned int N>
VectorSpace<N> Geometry<N>::orthonormalize(const VectorSpace<N>& basis){

  VectorSpace<N> orthonormalBasis;
  orthonormalBasis.reserve(basis.size());
  
  // returns the orthogonal projection of v over the space spanned by u
  std::function<SVector<N>(SVector<N>, SVector<N>)> projector = [](SVector<N> u, SVector<N> v) -> SVector<N> {
    double a = v.dot(u)/u.squaredNorm();
    // eigen cannot multiply a matrix by a constant. To allow element operations transform u into an array, perform
    // the multiplication and cast back to an eigen matrix
    return (a*(u.array())).matrix();
  };

  // take the first vector of the input basis as it is
  orthonormalBasis.push_back(basis[0]/(basis[0].norm()));

  // build orthonormal vectors following the modified gram-schmidt method
  for(int i = 1; i < basis.size(); ++i){
    orthonormalBasis.push_back(basis[i]);
    for(int j = 0; j < i; ++j){
      orthonormalBasis[i] -= projector(orthonormalBasis[j], basis[i]);
    }
    orthonormalBasis[i] /= orthonormalBasis[i].norm();
  }
  
  return orthonormalBasis;
}

// projects the point x on the space spanned by the vectors contained in basis
// (observe that an orthonormal basis is required, normalize first with
// orthonormalize() ) this returns a vector of the same dimension of the space
// where we are projecting written as linear combination of the elements of the set of basis vectors
template <unsigned int N>
DVector Geometry<N>::projectOnto(const VectorSpace<N>& spaceBasis, const SVector<N> &x){
  // build the projection onto the space spanned by the basis set
  Eigen::Matrix<double, Eigen::Dynamic, 1> projection;
  projection.resize(spaceBasis.size(),1);

  // values of projection[i] are the coefficients of the linear combination of spaceBasis vectors which gives the input vector x
  for(size_t i = 0; i < spaceBasis.size(); ++i){
    projection[i] = x.dot(spaceBasis[i])/(spaceBasis[i].norm());
  }

  return projection;
}

// project an N-dimensional point x on the space spanned by the set of basis
// vectors, returns an N-dimensional vector corresponding to the projected point (written with respect
// to the canonical basis of the N-dimensional space where x lies). Basis must be an orthonormal basis
template <unsigned int N>
SVector<N> Geometry<N>::projectInto(const VectorSpace<N>& basis, const SVector<N> &x){
  // build the projection operator on the space spanned by the basis
  Eigen::Matrix<double, N, Eigen::Dynamic> A;
  A.resize(N, basis.size());

  // values of projection[i] are the coefficients of the linear combination of basis vectors which gives the input vector x
  for(size_t i = 0; i < basis.size(); ++i){
    A.col(i) = basis[i];
  }

  // given the projection operator A*A^T, the projection of x is computed as (A*A^T)*x
  return (A*A.transpose())*x;
}

// compute the euclidean distance of x from the linear subspace spanned by basis and passing throught offset
// this allows to cope with affine spaces (i.e. planes or lines not passing throught the origin)
template <unsigned int N>
double Geometry<N>::getL2Distance(const VectorSpace<N>& basis, const SVector<N>& offset, const SVector<N> &x) {
  // project point on subspace spanned by the basis vector, compute the distance between
  // the point and its projection
  
  SVector<N> projection = projectInto(orthonormalize(basis), x-offset);

  // sum offset to the projection so that we can deal also with affine spaces
  return ((x-offset) - projection).squaredNorm();
}

#endif // __VECTOR_SPACE_H__
